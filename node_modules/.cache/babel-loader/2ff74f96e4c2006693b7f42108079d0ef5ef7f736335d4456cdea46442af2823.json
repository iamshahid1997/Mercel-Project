{"ast":null,"code":"// engagementHelper.js\n\nimport Highcharts, { time } from \"highcharts\";\nconst engagementHelper = {};\nengagementHelper.getChannelsWithMessagesOnMultipleDates = messageCountList => {\n  const channelCountMap = new Map();\n\n  // Count the number of unique dates each channel has messages on\n  for (const entry of messageCountList) {\n    const channelId = entry.channelId;\n    const timeBucket = entry.timeBucket.split('T')[0]; // Extract date part\n    if (channelCountMap.has(channelId)) {\n      channelCountMap.get(channelId).add(timeBucket); // if channelId found in channelCountMap, add timeBucket to the timeBucket Set.\n    } else {\n      channelCountMap.set(channelId, new Set([timeBucket])); // if channelId not in channelCountMap, add channelId with new Set for storing timeStamp\n    }\n  }\n\n  // Filter channels with messages on more than one date\n  const channelsWithMessagesOnMultipleDates = [];\n  for (const [channelId, dateSet] of channelCountMap) {\n    if (dateSet.size > 1) {\n      // dateSet have more than 1 values push that channelId in channelsWithMessagesOnMultipleDates\n      channelsWithMessagesOnMultipleDates.push(channelId);\n    }\n  }\n  return channelsWithMessagesOnMultipleDates;\n};\nengagementHelper.engagementMessageOverTimeChartOptions = (messageCountList, channels) => {\n  const channelsWithMessagesOnMultipleDates = engagementHelper.getChannelsWithMessagesOnMultipleDates(messageCountList);\n\n  // Filter the messageCountList to include only channels with messages on multiple dates\n  const filteredMessageCountList = messageCountList.filter(entry => channelsWithMessagesOnMultipleDates.includes(entry.channelId));\n\n  // Generate the options for the chart\n  const chartOptions = {\n    chart: {\n      type: 'line',\n      height: 400\n    },\n    title: {\n      text: \"Engagement Message Over Time\"\n    },\n    xAxis: {\n      type: 'datetime'\n    },\n    yAxis: {\n      title: {\n        text: 'Message Count'\n      }\n    },\n    tooltip: {\n      formatter: function () {\n        return `\n          Channel: ${this.series.name}<br>\n          Date: ${Highcharts.dateFormat('%Y-%m-%d', this.x)}<br>\n          Messages: ${this.y}\n        `;\n      }\n    },\n    series: []\n  };\n\n  // Add datasets for each channel with messages on multiple dates\n  for (const channel of channels) {\n    console.log(channel);\n    if (channelsWithMessagesOnMultipleDates.includes(channel.value)) {\n      const channelData = filteredMessageCountList.filter(entry => entry.channelId === channel.value);\n      const messageCounts = channelData.map(entry => ({\n        x: new Date(entry.timeBucket).getTime(),\n        y: parseInt(entry.count)\n      }));\n      const dataset = {\n        name: channel.name,\n        data: messageCounts,\n        marker: {\n          enabled: true,\n          radius: 4\n        }\n      };\n      chartOptions.series.push(dataset);\n    }\n  }\n  return chartOptions;\n};\nexport default engagementHelper;","map":{"version":3,"names":["Highcharts","time","engagementHelper","getChannelsWithMessagesOnMultipleDates","messageCountList","channelCountMap","Map","entry","channelId","timeBucket","split","has","get","add","set","Set","channelsWithMessagesOnMultipleDates","dateSet","size","push","engagementMessageOverTimeChartOptions","channels","filteredMessageCountList","filter","includes","chartOptions","chart","type","height","title","text","xAxis","yAxis","tooltip","formatter","series","name","dateFormat","x","y","channel","console","log","value","channelData","messageCounts","map","Date","getTime","parseInt","count","dataset","data","marker","enabled","radius"],"sources":["/Users/shahidansari/Documents/GitHub/Mercel-Project/src/utils/engagementHelper.js"],"sourcesContent":["// engagementHelper.js\n\nimport Highcharts, { time } from \"highcharts\";\n\nconst engagementHelper = {};\n\nengagementHelper.getChannelsWithMessagesOnMultipleDates = (messageCountList) => {\n  const channelCountMap = new Map();\n\n  // Count the number of unique dates each channel has messages on\n  for (const entry of messageCountList) {\n    const channelId = entry.channelId;\n    const timeBucket = entry.timeBucket.split('T')[0]; // Extract date part\n    if (channelCountMap.has(channelId)) {\n      channelCountMap.get(channelId).add(timeBucket); // if channelId found in channelCountMap, add timeBucket to the timeBucket Set.\n    } else {\n      channelCountMap.set(channelId, new Set([timeBucket])); // if channelId not in channelCountMap, add channelId with new Set for storing timeStamp\n    }\n  }\n\n  // Filter channels with messages on more than one date\n  const channelsWithMessagesOnMultipleDates = [];\n  for (const [channelId, dateSet] of channelCountMap) {\n    if (dateSet.size > 1) { // dateSet have more than 1 values push that channelId in channelsWithMessagesOnMultipleDates\n      channelsWithMessagesOnMultipleDates.push(channelId);\n    }\n  }\n\n  return channelsWithMessagesOnMultipleDates;\n};\n\nengagementHelper.engagementMessageOverTimeChartOptions = (messageCountList, channels) => {\n  const channelsWithMessagesOnMultipleDates = engagementHelper.getChannelsWithMessagesOnMultipleDates(messageCountList); \n\n  // Filter the messageCountList to include only channels with messages on multiple dates\n  const filteredMessageCountList = messageCountList.filter(entry =>\n    channelsWithMessagesOnMultipleDates.includes(entry.channelId)\n  );\n\n  // Generate the options for the chart\n  const chartOptions = {\n    chart: {\n      type: 'line',\n      height: 400,\n    },\n    title: {\n      text: \"Engagement Message Over Time\",\n    },\n    xAxis: {\n      type: 'datetime',\n    },\n    yAxis: {\n      title: {\n        text: 'Message Count',\n      },\n    },\n    tooltip: {\n      formatter: function () {\n        return `\n          Channel: ${this.series.name}<br>\n          Date: ${Highcharts.dateFormat('%Y-%m-%d', this.x)}<br>\n          Messages: ${this.y}\n        `;\n      },\n    },\n    series: [],\n  };\n\n  // Add datasets for each channel with messages on multiple dates\n  for (const channel of channels) {\n    console.log(channel)\n    if (channelsWithMessagesOnMultipleDates.includes(channel.value)) {\n      const channelData = filteredMessageCountList.filter(entry => entry.channelId === channel.value);\n      const messageCounts = channelData.map(entry => ({\n        x: new Date(entry.timeBucket).getTime(),\n        y: parseInt(entry.count),\n      }));\n      const dataset = {\n        name: channel.name,\n        data: messageCounts,\n        marker: {\n          enabled: true,\n          radius: 4,\n        },\n      };\n      chartOptions.series.push(dataset);\n    }\n  }\n\n  return chartOptions;\n};\n\nexport default engagementHelper;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}